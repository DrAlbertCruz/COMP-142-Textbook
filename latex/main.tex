\documentclass[11pt]{book}

\usepackage{amsmath}

\newcommand\Mydiv[2]{%
$\strut#1$\kern.25em\smash{\raise.3ex\hbox{$\big)$}}$\mkern-8mu
        \overline{\enspace\strut#2}$}

\begin{document}

\section{Preface\label{sec:preface}}

This textbook is an open-source document that meets the requirements of COMP 142 Computer Architecture and Organization. The goal of the class is to study the organization and behavior of real computer systems at the assembly-language level, the mapping of statements and constructs in a high-level language onto sequences of machine instructions is studied, as well as the internal representation of simple data types and structures. It also covers numerical computation, noting the various data representation errors and potential procedural errors.

The general topics covered by the class are:

\begin{enumerate}
\item Bits, bytes, and words
\item Numeric data representation and number bases
\item Fixed- and floating-point systems
\item Signed and twos-complement representations
\item Representation of nonnumeric data (character codes, graphical data)
\item Representation of records and arrays
\item Basic organization of the von Neumann machine
\item Control unit; instruction fetch, decode, and execution
    Instruction sets and types (data manipulation, control, I/O)
\item Assembly/machine language programming
\item Instruction formats
\item Addressing modes
\item Subroutine call and return mechanisms
\item I/O and interrupts
\end{enumerate}

\chapter{Number Bases, Representation and Storage\label{sec:data}}

Computers use binary numbers because they are made up of electronic components called transistors, which can be either in an  on or off state. By using a binary numbering system, which only has two digits (0 and 1), computers can represent and process information using these on and off states of transistors.

A binary number is a number expressed in the base-2 numeral system, a method of mathematical expression which uses only two symbols: typically 0 or 1. In more mathematical or logical contexts 0 is treated as False and 1 is treated as True.

In base-2 each digit is referred to as a bit, or binary digit. Because of its straightforward implementation in digital electronic circuitry using logic gates, the binary system is used by almost all modern computers and computer-based devices, as a preferred system of use, over various other human techniques of communication, because of the simplicity of the language.

The modern binary number system was studied in Europe in the 16th and 17th centuries by Thomas Harriot, Juan Caramuel y Lobkowitz, and Gottfried Leibniz. However, systems related to binary numbers have appeared earlier in multiple cultures including ancient Egypt, China, and India. Leibniz was specifically inspired by the \textit{I Ching}, a classical Chinese text from the 9th century BCE. 

\section{Binary Numbers\label{sec:data:bin}}

A number has an intrinsic magnitude. A number base is merely a way to represent a number. The value of the number does not change when transitioning between number bases. Most people use a base-10, also known as decimal. For example, 667 is a decimal number. In more mathematical contexts with numbers of different bases, you can write the number in parenthesis with the base in subscript, for example: $667_{10}$. Binary numbers are base-2. $667$ in base-2 is representated as 
$1010011011_2$. When spoken, binary numerals are usually read digit-by-digit, in order to distinguish them from decimal numerals. For example, $1010011011_2$ is pronounced \textit{one zero one zero zero one one zero one one}. It would be confusing to refer to the number as \textit{one billion ten million eleven thousand and eleven} which represents a different value. Note that the number base should not change the intrinsic value of a number.

The order of the digits in a binary number represents their power of two. The right-most digit called the least significant bit (LSB) represents the power of $2^0$. The left-most digit called the most significant bit (MSB) represents the power of $2^{n-1}$ where $n$ is the length of the sequence. For example, with $1010011011_2$ the LSB is 1, representing $2^0$, and the MSB is $2^9$ because the sequence is 10 bits long. A sequence of binary numbers can be written as an expansion of power of two:

\begin{equation}\label{sec:data:bin:667bin}
	1 \times 2^9 + 0 \times 2^8 + 1 \times 2^7 + 0 \times 2^6 + 0 \times 2^5 + 1 \times 2^4 + 1 \times 2^3 + 0 \times 2^2 + 1 \times 2^1 + 1 \times 2^0
\end{equation}

When converting from binary to decimal, expand the terms as above. This is the simplest way to convert a binary number to decimal.

\subsection{Converting to Binary Numbers\label{sec:data:bin:bin}}

Suppose that you want to convert $667_{10}$ to decimal. Expanding the number in terms of powers of two is the simplest way to convert a decimal number to binary (such as in Equation \ref{sec:data:bin:667bin}). Prepare a table counting left-to-right in powers of 2 starting with the power of two that is less than the magnitude of the number you are converting. For $667_{10}$, this is $512_{10}$ or $2^9$:

\vspace{1em}
\begin{tabular}{|l|l|l|l|l|l|l|l|l|l|l|}\hline
Power & $2^9$ & $2^8$ & $2^7$ & $2^6$ & $2^5$ & $2^4$ & $2^3$ & $2^2$ & $2^1$ & $2^0$ \\\hline\hline
Decimal & 512 & 256 & 128 & 64 & 32 & 16 & 8 & 4 & 2 & 1 \\\hline
Digit &  &  &  &  &  &  &  &  &  &  \\\hline
\end{tabular}

\vspace{1em}
Start from left to right. If you can subtract the number and have a result greater than or equal to zero, indicate 1 for the digit. Then, carry out the subtraction and use this new value for the next column. If you cannot carry out the subtraction without the number becoming negative, skip to the next column. Repeat this procedure for the next column.

 $667-512=155$, so we can indeed subtract $512_2$ from $667_2$. Write 1 in the digit, and use the value of $155$ for the next column. $155-256<0$. We cannot subtract without the number becoming negative, so we write 0 in the current column. However, $155-128=27$. Write 1 in the digit for this next column. And so on until the last digit. If you have any remaining value beyond the right-most column you have made a mistake, check your work.

\vspace{1em}
\begin{tabular}{|l|l|l|l|l|l|l|l|l|l|l|}\hline
Power & $2^9$ & $2^8$ & $2^7$ & $2^6$ & $2^5$ & $2^4$ & $2^3$ & $2^2$ & $2^1$ & $2^0$ \\\hline\hline
Decimal & 512 & 256 & 128 & 64 & 32 & 16 & 8 & 4 & 2 & 1 \\\hline
Digit & 1 & 0 & 1 & 0 & 0 & 1 & 1 & 0 & 1 & 1 \\\hline
\end{tabular}

\vspace{1em}

\paragraph{Divide-by-2} %
There is a more formal way to carry out this procedure, called the divide-by-2 method. With the previous algorithm the digit column is noting if there would be a remainder when carrying out integer division by its respective power of 2. An alternative way to convert the number is as follows.

Start with the number you want to convert. Perform an integer division by 2. Note that an integer division does not produce a fractional result. It should produce an integer and a remainder if the divisor cannot cleanly divide the dividend. Write the remainder to the right of the calculation, and write the result \textit{below} your calculation. Continue dividing by 2 until you reach a dividend of 1. The binary representation of the number is read from top-to-bottom of the remainder values.

\vspace{1em}

 \Mydiv{2}{667} \hspace{1cm} 1
 
 \Mydiv{2}{333} \hspace{1cm} 1
 
 \Mydiv{2}{166} \hspace{1cm} 0
 
 \Mydiv{2}{83} \hspace{1.2cm} 1
 
 \Mydiv{2}{41} \hspace{1.2cm} 1
 
 \Mydiv{2}{20} \hspace{1.2cm} 0
 
 \Mydiv{2}{10} \hspace{1.2cm} 0
 
 \Mydiv{2}{5} \hspace{1.2cm} 1
 
 \Mydiv{2}{2} \hspace{1.2cm} 0
 
 \Mydiv{2}{1} \hspace{1.2cm} 1
 
\vspace{1em}

$667/2$ has a remainder of 1 because it is odd, so write this to the left of the division, and write the result, $333$ below. Repeat this step. $333/2$ also has a remainder of 1, and its result is 166. $166$ is even and has a remainder of 0. And so on until we reach $2/1$.

To obtain the answer read from the top down. The bottom digit is the LSB and the top digit is the MSB. The result is $1101100101_2$ which is consistent with our previous examples.

\subsection{Bits, Bytes, Bibytes and Words\label{sec:data:bin:words}}
 
Long sequences of binary numbers are hard for people to read and understand. Most people are only familiar with base-10, and long sequences of binary numbers are more difficult to process than a long decimal number. To assist with long numbers, decimal numbers often use the comma (,) to separate every three digits. For example, the number 1234567890 can be written as 1,234,567,890. The comma makes it easier to interpret.

\paragraph{Byte} There are similar systems in computer achitecture. You are already familiar with a bit, which is a single digit. The byte is a unit of digital information that most commonly consists of eight bits. Historically, the byte was the number of bits used to encode a single character of text in a computer and for this reason it is the smallest addressable unit of memory in many computer architectures. To disambiguate arbitrarily sized bytes from the common 8-bit definition, network protocol documents such as The Internet Protocol (RFC 791) refer to an 8-bit byte as an octet. The unit symbol for the byte was designated as the upper-case letter B by the International Electrotechnical Commission (IEC) and Institute of Electrical and Electronics Engineers (IEEE).

The size of the byte has historically been hardware-dependent and no definitive standards existed that mandated the size. The modern de facto standard of eight bits, as documented in ISO/IEC 2382-1:1993, is a convenient power of two. Continuing with our example of $1010011011_2$, you can separate each unit of 8 bits using a comma:

\begin{align*}
10 \hspace{0.25cm} 10011011& \\
00000010 \hspace{0.25cm} 10011011&
\end{align*}

Note that you group starting from the least significant side. The second representation has zero-filled the remaining 10 so that it occupies a whole byte. Inserting 0's does not change the value of the number.

\paragraph{Bibytes} With very large decimal numbers, we abberviate the number. For example, 1,000 grams can be written as 1 kilogram. A similar system can be applied to binary numbers. However, the decimal unit system of applying prefixes such as kilo-, mega-, etc. uses base-10.

Computers use bibytes (binary bytes) instead of decimal bytes.  In the past, computers used decimal bytes (KB, MB, GB, etc.), where each byte represented 10 different values (0 to 9). However, as computers and digital systems became more prevalent, it became clear that the binary numbering system was a more natural fit for digital devices. This led to the adoption of binary prefixes, such as kibi-, mebi-, and gibi-, which are based on powers of 2 and are used to denote units of digital information in binary form.

TODO

\paragraph{Words} Another important concept  TODO


\section{Applied Number Bases\label{sec:data:bases}}

\subsection{Hexadecimal\label{sec:data:bases:hex}}

Programmers often use hexadecimal (base-16) because it provides a convenient way to represent and manipulate binary data in a more human-readable format. Hexadecimal is a base-16 numbering system that uses the digits 0-9 and the letters A-F to represent 16 possible values. Each hexadecimal digit represents four binary digits, making it easy to represent and manipulate binary data in a more concise and readable format. For example, the binary number 10101010 can be represented as the hexadecimal number AA. Two hexadecimal digits are one byte. Programmers use hexadecimal in many different contexts, given below.

\paragraph{Memory addresses} Memory addresses in computer systems are often represented in hexadecimal, making it easier to understand and manipulate memory locations. 

\paragraph{Color codes} Colors in graphics applications are often represented as a combination of red, green, and blue values, each ranging from 0 to 255. In hexadecimal, these values can be represented using two digits, providing a concise and readable format for color codes.

\paragraph{Bit manipulation} When working with binary data, programmers often use bitwise operations to manipulate individual bits. Hexadecimal provides a convenient way to represent and manipulate groups of four bits at a time, making bitwise operations more efficient and readable.

\section{Number Storage\label{sec:data:bin:endian}}

\section{Endianness\label{sec:data:bin:endian}}

In computing, endianness is the order or sequence of bytes of a word of digital data in computer memory. Endianness is primarily expressed as big-endian (BE) or little-endian (LE). A big-endian system stores the most significant byte of a word at the smallest memory address and the least significant byte at the largest. A little-endian system, in contrast, stores the least-significant byte at the smallest address. Danny Cohen introduced the terms big-endian and little-endian into computer science for data ordering in an Internet Experiment Note published in 1980. 

The adjective endian has its origin in the writings of 18th century Anglo-Irish writer Jonathan Swift. In the 1726 novel Gulliver's Travels, he portrays the conflict between sects of Lilliputians divided into those breaking the shell of a boiled egg from the big end or from the little end. Because the emperor's son had cut his finger while opening an egg from the big end, doing so was prohibited by an imperial edict; those who rebelled and did so were called "Big-Endians" (Swift did not use the term Little-Endians in the work). Cohen makes the connection to Gulliver's Travels explicit in the appendix to his 1980 note. 



\end{document}