\documentclass[11pt]{book}
\begin{document}

\section{Preface\label{sec:preface}}

This textbook is an open-source document that meets the requirements of COMP 142 Computer Architecture and Organization. The goal of the class is to study the organization and behavior of real computer systems at the assembly-language level, the mapping of statements and constructs in a high-level language onto sequences of machine instructions is studied, as well as the internal representation of simple data types and structures. It also covers numerical computation, noting the various data representation errors and potential procedural errors.

The general topics covered by the class are:

\begin{enumerate}
\item Bits, bytes, and words
\item Numeric data representation and number bases
\item Fixed- and floating-point systems
\item Signed and twos-complement representations
\item Representation of nonnumeric data (character codes, graphical data)
\item Representation of records and arrays
\item Basic organization of the von Neumann machine
\item Control unit; instruction fetch, decode, and execution
    Instruction sets and types (data manipulation, control, I/O)
\item Assembly/machine language programming
\item Instruction formats
\item Addressing modes
\item Subroutine call and return mechanisms
\item I/O and interrupts
\end{enumerate}

\chapter{Data Representation\label{sec:data}}

Computers use binary numbers because they are made up of electronic components called transistors, which can be either in an  on" or "off" state. By using a binary numbering system, which only has two digits (0 and 1), computers can represent and process information using these "on" and "off" states of transistors.

A binary number is a number expressed in the base-2 numeral system, a method of mathematical expression which uses only two symbols: typically 0 or 1. In more mathematical or logical contexts 0 is treated as False and 1 is treated as True.

The base-2 numeral system is a positional notation with a base of 2. Each digit is referred to as a bit, or binary digit. Because of its straightforward implementation in digital electronic circuitry using logic gates, the binary system is used by almost all modern computers and computer-based devices, as a preferred system of use, over various other human techniques of communication, because of the simplicity of the language.

The modern binary number system was studied in Europe in the 16th and 17th centuries by Thomas Harriot, Juan Caramuel y Lobkowitz, and Gottfried Leibniz. However, systems related to binary numbers have appeared earlier in multiple cultures including ancient Egypt, China, and India. Leibniz was specifically inspired by the \textit{I Ching}, a classical Chinese text from the 9th century BCE. 

\section{Binary Numbers\label{sec:data:bases}}

You can think of a number base as the way to represent a number. The value of the number does not change when transitioning between number bases. Most people use a base of 10, also known as decimal. For example, 667 is a decimal number. In more mathematical contexts with numbers of different bases, you can write the number in parenthesis with the base in subscript, for example: $667_{10}$. Binary numbers are base 2. $667$ in base 2 is representated as 
$1010011011_2$. When spoken, binary numerals are usually read digit-by-digit, in order to distinguish them from decimal numerals. For example, $1010011011_2$ is pronounced \textit{one zero one zero zero one one zero one one}. It would be confusing to refer to the number as \textit{one billion ten million eleven thousand and eleven} which represents a different value. Note that the number base should not change the intrinsic value of a number.

The order of the digits in a binary number represents their power of two. The right-most digit called the least significant bit (LSB) represents the power of $2^0$. The left-most digit called the most significant bit (MSB) represents the power of $2^{n-1}$ where $n$ is the length of the sequence. For example, with $1010011011_2$ the LSB is 1, representing $2^0$, and the MSB is $2^9$ because the sequence is 10 bits long. A sequence of binary numbers can be written as an expansion of power of two:

\begin{equation}\label{sec:data:bases:667bin}
	1 \times 2^9 + 0 \times 2^8 + 1 \times 2^7 + 0 \times 2^6 + 0 \times 2^5 + 1 \times 2^4 + 1 \times 2^3 + 0 \times 2^2 + 1 \times 2^1 + 1 \times 2^0
\end{equation}

When converting from binary to decimal, expand the terms as above. This is the simplest way to convert a binary number to decimal.

\subsection{Converting to Binary Numbers\label{sec:data:bases:bin}}

Suppose that you want to convert $667_{10}$ to decimal. Expanding the number in terms of powers of two is the simplest way to convert a decimal number to binary (such as in Equation \label{sec:data:bases:667bin}). Prepare a table with the power of two that is just less than the magnitude of the number you are converting. For $667_{10}$, this is $512_{10}$ or $2^9$:

\vspace{1em}
\begin{tabular}{|l|l|l|l|l|l|l|l|l|l|l|}\hline
Power & $2^9$ & $2^8$ & $2^7$ & $2^6$ & $2^5$ & $2^4$ & $2^3$ & $2^2$ & $2^1$ & $2^0$ \\\hline\hline
Decimal & 512 & 256 & 128 & 64 & 32 & 16 & 8 & 4 & 2 & 1 \\\hline
Digit &  &  &  &  &  &  &  &  &  &  \\\hline
\end{tabular}

\vspace{1em}
Start from left to right. If you can subtract the number without it becoming negative, indicate 1 for the digit. Then, carry out the subtraction and use this new value for the next column. If you cannot carry out the subtraction without the number becoming negative, skip to the next column. Repeat this procedure for the next column.

 $667-512=155$, so we can indeed subtract $512_2$ from $667_2$. We can note 1 in the digit, and use the value of $155$ for the next column. $155-256<0$. We cannot subtract without the number becoming negative, so we note 0 as the digit for this current column. However, $155-128=27$. So we can note 1 in the digit for this next column. And so on until the last digit. If you have any remaining value beyond the right-most column you have made a mistake, check your work.

\vspace{1em}
\begin{tabular}{|l|l|l|l|l|l|l|l|l|l|l|}\hline
Power & $2^9$ & $2^8$ & $2^7$ & $2^6$ & $2^5$ & $2^4$ & $2^3$ & $2^2$ & $2^1$ & $2^0$ \\\hline\hline
Decimal & 512 & 256 & 128 & 64 & 32 & 16 & 8 & 4 & 2 & 1 \\\hline
Digit & 1 & 0 & 1 & 0 & 0 & 1 & 1 & 0 & 1 & 1 \\\hline
\end{tabular}

\vspace{1em}
There is a more formal way to carry out this procedure, called the \textbf{divide-by-2} method. Essentially, with the previous algorithm the digit column is noting if there would be a remainder when carrying out integer division by its respective power of 2. An alternative way to convert the number is as follows.

Start with the number you want to convert. Perform an integer division by 2. Note that an integer division does not produce a fractional result. It should produce an integer and a remainder if the divisor cannot cleanly divide the dividend. Write the remainder to the right of the calculation, and write the result \textit{below} your calculation. Continue dividing by 2 until you reach a dividend of 1. The binary representation of the number is read from top-to-bottom of the remainder values.


 
 
\end{document}